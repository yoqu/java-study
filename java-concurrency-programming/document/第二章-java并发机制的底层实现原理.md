# JAVA并发机子的底层实现原理

`author` : [yoqu](http://www.yoqu.org)

`createTime` : 2017年05月10 下午10:33

---

JAVA代码在编译后变成JAVA字节码,字节码被类加载器加载到jvm中,jvm执行字节码,转换未汇编指令在cpu上执行,JAVA所使用的并发机制依赖于jvm的实现和cpu的指令.

## 3.1 volatile的应用

volatile是轻量级的synchronized,它在多处理器中开发保证了共享变量的"可见性",即当一个线程在修改共享变量时,另一个线程能读到张合格修改的值.volatile 使用恰当的话,比synchronized使用成本和执行成本更低,因为不会引起线程上下文的切换和调度

* 如何保证可见性？

  在X86处理器下面使用JIT编译器生成的汇编指令查看volatile**写**操作

  ```java
  instance = new SingleInstance();//instance 是volatile 变量	
  ```

   转换为汇编代码如下：

  ```
  0X01a3de1d: movb $0X0,0X1104800(%esi);0X01a3de24: lock add1 $0X0 (%esp);
  ```

  通过查IA-32架构开发手册可知，lock前缀的指令再多核处理器下会引发两件事：

  （1） 将当前处理器缓存行的数据写回到系统内存。

  （2） 写回内存的操作会使其他cpu缓存了该内存地址的数据无效。

  volatile 的两条实现原则：

  1. **lock前缀指令会引起处理器缓存写回内存**。目前的处理器中，如果访问内存区域已经缓存在处理器内部，不会声言 **lock**信号，他会锁定这块区域的缓存并写回到内存，并使用缓存一致性机制来确保修改的原子性，该操作被称为 “**缓存锁定**”，缓存一致性机制会组织同时修改两个以上处理器缓存的内存区域数据。


  2. **一个处理器的缓存写回到内存会到之后其他处理器的缓存无效**。IA-32处理器和Intel 64处理器使用MESI控制协议维护内部缓存和其他处理器缓存的一致性。

* volatile的使用优化

**追加字节能优化性能**？一个对象的引用占用4个字节，追加15个变量，加上父类的value，一共64字节。

**为什么追加64字节能提高并发编程的效率？** 因为对于intel i7，酷睿，atom和NetBurst，cpu的高速缓存行是64字节宽，如果队列的头结点和尾节点不足64个字节宽，会将他们读取到一个缓存行中，多处理器下都会缓冲好难过相同的头尾节点，当修改头节点时，整行锁定，那么会到导致其他处理器无法访问自己的高速缓存中的尾节点，而队列的入队和出队需要不停修改头尾节点，所以多处理器的情况会验证影响队列的入队和出队效率，使用64字节方式可以避免头尾节点加载到同一缓存行，使头尾修改时不会相互锁定。

当以下两种情况不适合追加到64字节：

* 缓存行非64字节宽的处理器
* 共享变量不会被频繁地写

